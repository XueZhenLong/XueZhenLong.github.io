{"pages":[],"posts":[{"title":"JDBC概述","text":"1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。","link":"/2020/08/16/JDBC/"},{"title":"JDBC-CURD","text":"一. 使用PreparedStatement实现CRUD操作1. 操作数据库的流程1.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 1.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 2. PreparedStatement的使用2.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 2.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 2.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 2.4 对数据库连接与关闭的操作进行封装账户密码在properties中存储 1234user=rootpassword=123456xzlurl=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 连接: 123456789101112131415161718192021public static Connection getConnection() throws Exception { /* 获取数据库的连接操作 */ //1.读取配置文件中的4个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); //4.返回当前连接 return conn; } 关闭: 12345678910111213141516171819public static void closeResource(Connection conn, Statement ps) { /* 关闭连接和Statement的操作 */ try { if (ps != null) { ps.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } try { if (conn != null) { conn.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } } 2.5使用PreparedStatement实现增.删.改.操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) { PreparedStatementTest1 pst = new PreparedStatementTest1(); String name; String email; String birth; String sql = \"insert into customers(name,email,birth)value(?,?,?)\"; Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要添加的员工姓名:\"); name = sc.next(); System.out.println(\"请输入您要添加的员工邮箱地址:\"); email = sc.next(); System.out.println(\"请输入您要添加的员工出生日期:\"); birth = sc.next(); int update = pst.update(sql, name, email, birth); if (update &gt; 0) { System.out.println(\"恭喜您添加数据成功!!\"); } else { System.out.println(\"不好意思,没有添加成功\"); } sc.close(); }//对于 修改.删除.添加 操作进行封装!public int update(String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //4.执行 //execute只是执行,executeUpdate执行完毕后会返回操作成功的影响行数,以此可判断操作是否成功. int i = ps.executeUpdate(); return i; } catch (Exception e) { e.printStackTrace(); }finally { //5.资源的关闭 JDBCUtils.closeResource(conn,ps); } return 0;} 2.使用PreparedStatement实现查询操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Testpublic void testGetForList(){ String sql = \"select id,name,email from customers where id&lt; ?\"; List&lt;Customers&gt; list = getForList(Customers.class, sql, 12); Iterator&lt;Customers&gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); }}public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz,String sql,Object...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //创建连接 conn = JDBCUtils.getConnection(); //预编译sql语句 ps = conn.prepareStatement(sql); //填写占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()){ T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel()// String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i+1);//利用反射,将对象指定名的属性赋 值名columnName,为指定的值 columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t,columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps,rs); } return null;}","link":"/2020/08/18/JDBC-CURD/"},{"title":"JDBC与数据库的连接","text":"一. 数据库连接的三要素要素一: Driver接口实现类1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： **com.mysql.jdbc.Driver 1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 要素二：URL2.1 URL的组成 JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 2.2 常用的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 (重点)数据库连接方式举例12345678910111213141516171819202122//方式一:数据库的连接 @Test public void testConnection1() throws SQLException { //1.获取Driver的实现类对象 Driver driver = new com.mysql.jdbc.Driver(); //jdbc:mysql: 协议 //localhost: ip地址 //3306: 默认mysql的端口号 //test: test数据库 //2.创建url 连接的数据库地址 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); //将用户名和密码封装在properties中 info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 123456789101112131415161718//方式二:对方式一的迭代:在如下的程序中不出现第三方的api,是的程序具有更好的可以移植性. @Test public void testConnection2() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供要连接的数据库 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 12345678910111213141516171819//方式三:使用DriverManager替换Driver @Test public void testConnection3() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //3. 注册驱动 DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 12345678910111213141516171819202122232425//方式四:对方式三的迭代:可以只是加载驱动,不用显示的注册驱动过了. @Test public void testConnection4() throws Exception { //1. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //2. 加载Driver Class.forName(\"com.mysql.jdbc.Driver\"); /*Driver内部静态代码块中帮助我们创建了driver实例对象 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\");} } */// Driver driver = (Driver) clazz.newInstance();// //3. 注册驱动// DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 123456789101112131415161718192021222324//方式五(最终版):将数据库连接需要的4个基本信息声明在配置文件中,通过读取配置文件的方式,获取连接 /* 此种方法的好处: 1.实现了数据与代码的分离.实现解耦 2.如果需要修改配置文件信息,可以避免程序重新打包 */ @Test public void getConnection5() throws IOException, ClassNotFoundException, SQLException { //1.读取配置文件中的4个基本信息 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); }","link":"/2020/08/16/JDBC%E7%9A%84%E8%BF%9E%E6%8E%A5/"},{"title":"我的博客建成日记","text":"第一天 2020-8-81.学会了hexo的基本搭建2.测试了发布功能3.选择合适的主题icarus4.阅读主题作者的说明文档5.连接github 参考-官方文档:https://ppoffice.github.io/hexo-theme-icarus 第二天 2020-8-91.对于文章附带的图片进行测试2.增加夜间浏览模式3.增加bolg背景4.增加鼠标点击效果5.参考其对自己的博客进行部署.6.两个仓库的同步测试!—f**k 浪费了两个小时 失败了 我还是放弃吧…就用github了 这是一个重新部署环境的测试 呜呜呜呜 参考-夜间模式:https://www.imaegoo.com/2020/icarus-night-mode-3/-背景:https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1186779&amp;highlight=icarus-鼠标效果:https://zhuanlan.zhihu.com/p/69211731 第三天 2020-8-101.添加valine评论系统2.添加分享按钮ps:博客的基础功能完善 3.目录功能测试第四天 2020-8-101.两个仓库同步部署测试! 博客同时部署了coding 与 github page 国内coding会快很多. coding: https://1als1k.coding-pages.com/ github: https://xuezhenlong.work/ ps:花了一块钱买的域名 hhhhhhhh 总结:博客的基础功能已经实现,目前就这个样子了. 参考-评论:https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/","link":"/2020/08/08/Xue's%20Blog/"},{"title":"学习路线","text":"一. 编程基础1. java语言1.语言基础 基础语法 面向对象 接口 容器 异常 泛型 反射 注解 I/O 图形化(如swing) 2. JVM 类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优 3. 并发/多线程 并发编程基础 线程池 锁 并发容器 原子类 juc并发工具 2. 数据结构和算法1. 数据结构 字符串 数组 链表 二叉树 堆.栈.队列 哈希 2. 算法 查找 排序 贪心 分治 动态规划 回溯 3. 计算机网络 ARP协议 IP/ICMP协议 TCP/UDP协议 DNS/HTTP/HTTPS协议 Session/Cookie 4. 数据库/SQL SQL语句书写 SQL语句优化 事物以及隔离级别 索引 锁 5. 操作系统 进程/线程 并发/锁 内存管理和调度 I/O原理 6. 设计模式 单例模式 工厂模式 代理模式 策略 模板方法 观察者 适配器 责任链 建造者 二. 开发工具1. 集成开发环境 Eclipse IDEA VSCode 2. Linux系统 Linux常用命令 基本Shell脚本 3. 代码管理工具 Git SVN 4. 项目管理/构建工具 Maven Gradle 三. 应用框架1. 后端1. Spring家族 Spring SpringMVC SpringBoot 2. 服务器软件 Web服务器 Nginx 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. 中间件 缓存 Redis 5大数据类型 事务 消息通知 管道 持久化 集群 memcache 消息队列 RocketMQ RabbitMq Kafka RPC结构 Dubbo GRPC Thrift SpringCloud Netty 4. 数据库 ORM层框架 Mybatis Hibernate JPA 连接池1. Druid 2. HikariCP 3. C3P0 分库分表1. Mycat 2. Sharding-JDBC 3. Sharding-Sphere 5. 搜索引擎 Solr ElasticSearch 6. 分布式/微服务 服务发现/注册1. Rureka 2. Consul 3. Zookeeper 4. Nacos 网关1. Zuul 2. Gateway 服务调用(负载均衡) Ribbon Feign 熔断/降级 Hystrix 配置中心 Config Apollo Nacos 认证和鉴权 Shiro SpringSecurity OAuch2 SSO 分布式事务 JTA接口 2PC/3PC XA模式 TCC模式 SAGA模式 LCN模式 任务调度 Quartz Rlastic-Job 链路追踪与监控 Zipkin Sleuth Skywalking 日志分析与监控 ELK 虚拟化/容器化 容器技术 容器编排技术 2. 前端1. 基础套餐 三大件 HEML Javascript CSS 基础库 Jquery Ajax 2. 模板框架 JSP/JSTL(了解 过时了) Thymeleaf FreeMarker 3. 组件化框架 Node VUE React Angular 四. 运维知识1. Web服务器​ 1. Nginx 2. 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. CDN加速4. 持续集成/持续发布 Jenkins 5. 代码质量检查 Sonar 6. 日志收集/分析 ELK 五. 平稳降落1.调节心态2. 虚心学习3. 持之以恒","link":"/2020/08/15/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"学习路线","slug":"学习路线","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"categories":[]}