{"pages":[],"posts":[{"title":"HTML基础","text":"@Author: Xue ZhenLong @Address: Beijing province, China web概念概述123456789101112131415161718192021222324252627282930313233343536373839* JavaWeb： * 使用Java语言开发基于互联网的项目* 软件架构： 1. C/S: Client/Server 客户端/服务器端 * 在用户本地有一个客户端程序，在远程有一个服务器端程序 * 如：QQ，迅雷... * 优点： 1. 用户体验好 * 缺点： 1. 开发、安装，部署，维护 麻烦 2. B/S: Browser/Server 浏览器/服务器端 * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 * 优点： 1. 开发、安装，部署，维护 简单 * 缺点： 1. 如果应用过大，用户的体验可能会受到影响 2. 对硬件要求过高* B/S架构详解 * 资源分类： 1. 静态资源： * 使用静态网页开发技术发布的资源。 * 特点： * 所有用户访问，得到的结果是一样的。 * 如：文本，图片，音频、视频, HTML,CSS,JavaScript * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 2. 动态资源： * 使用动态网页及时发布的资源。 * 特点： * 所有用户访问，得到的结果可能不一样。 * 如：jsp/servlet,php,asp... * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 * 我们要学习动态资源，必须先学习静态资源！* 静态资源： * HTML：用于搭建基础网页，展示页面的内容 * CSS：用于美化页面，布局页面 * JavaScript：控制页面的元素，让页面有一些动态的效果 HTML基础1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 概念：是最基础的网页开发语言 * Hyper Text Markup Language 超文本标记语言 * 超文本: * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. * 标记语言: * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml * 标记语言不是编程语言2. 快速入门： * 语法： 1. html文档后缀名 .html 或者 .htm 2. 标签分为 1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 3. 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 5. html的标签不区分大小写，但是建议使用小写。 * 代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt;3. 标签学习： 1. 文件标签：构成html最基本的标签 * html:html文档的根标签 * head：头标签。用于指定html文档的一些属性。引入外部的资源 * title：标题标签。 * body：体标签 * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档 2. 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width='20' ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 练习题1123456789101112131415161718192021222324252627282930313233343536373839404142* 案例：java简介&lt;!DOCTYPE html&gt;&lt;html lang=\"ch\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;java简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; java简介 &lt;/h1&gt; &lt;hr color=\"#ffd700\"&gt; &lt;p&gt; &lt;font color=\"#FF0000\"&gt;\"我是一只快乐的小小薛\"&lt;/font&gt;开始java&lt;b&gt;&lt;i&gt;介绍&lt;/i&gt;&lt;/b&gt;20世纪90年代，硬件领域出现了单片式计算机系统，这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品（如电视机顶盒、面包烤箱、移动电话等）的智能化程度。Sun公司为了抢占市场先机，在1991年成立了一个称为Green的项目小组，帕特里克、詹姆斯·高斯林、麦克·舍林丹和其他几个工程师一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面研究开发新技术，专攻计算机在家电产品上的嵌入式应用。 &lt;/p&gt; &lt;p&gt; 由于C++所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++程序过于复杂和庞大。另外由于消费电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序跨平台运行也是个难题。为了解决困难，他们首先着眼于语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后，能有半导体芯片生产商开发和生产这种硬件平台。对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了留在C++的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发了一种称为Oak的面向对象语言。 &lt;/p&gt; &lt;p&gt; 由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。 &lt;/p&gt; &lt;p&gt; 1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。 &lt;/p&gt; &lt;hr color=\"#ffd700\"&gt; &lt;font color=\"gray\" size=\"2\"&gt; &lt;center&gt; 以上内容取自百度百科&lt;br&gt; 版权所有Copyright 2000-2020&amp;copy;, All Rights Reserved 北京ICP备20000607 &lt;/center&gt; &lt;/font&gt; &lt;/body&gt;&lt;/html&gt; 效果截图: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576773. 图片标签： * img：展示图片 * 属性： * src：指定图片的位置 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src=\"image/jingxuan_2.jpg\" align=\"right\" alt=\"古镇\" width=\"500\" height=\"500\"/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src=\"./image/jiangwai_1.jpg\"&gt; &lt;img src=\"../image/jiangwai_1.jpg\"&gt;4. 列表标签： * 有序列表： * ol: * li: * 无序列表： * ul: * li:5. 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * 代码： &lt;!--超链接 a--&gt; &lt;a href=\"http://www.itcast.cn\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_self\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_blank\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"./5_列表标签.html\"&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=\"mailto:itcast@itcast.cn\"&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\"&gt;&lt;img src=\"image/jiangwai_1.jpg\"&gt;&lt;/a&gt;6. div和span： * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 1. &lt;header&gt;：页眉 2. &lt;footer&gt;：页脚 8. 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 HTML标签：表单标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* 表单： * 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性 * 表单项标签： * input：可以通过type属性值，改变元素展示的样式 * type属性： * text：文本输入框，默认值 * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 * password：密码输入框 * radio:单选框 * 注意： 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 3. checked属性，可以指定默认值 * checkbox：复选框 * 注意： 1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 2. checked属性，可以指定默认值 * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 * select: 下拉列表 * 子元素：option，指定列表项 * textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 练习题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;登录测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"#\" method=\"get\"&gt;&lt;table border=\"1\" width=\"20%\" &gt;&lt;tr&gt; &lt;td&gt; 用户名 &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"uersname\" placeholder=\"请输入用户名\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 密码 &lt;/td&gt; &lt;td&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; Email &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"Email\" placeholder=\"请输入邮箱\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 姓名 &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"name\" placeholder=\"请输入姓名\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 手机号 &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"phone\" placeholder=\"请输入手机号\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 性别 &lt;/td&gt; &lt;td&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt;女 &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 出生日期 &lt;/td&gt; &lt;td&gt; &lt;input type=\"date\" name=\"出生日期\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt; 验证码 &lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td align=\"center\" colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"注册\" &gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果截图:","link":"/2020/08/22/HTML%E5%9F%BA%E7%A1%80/"},{"title":"DAO及相关实现类","text":"@Author: Xue ZhenLong @Address: Beijing province, China 一.封装了针对于数据表的通用的操作–基础的DAO DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 关系图 ###【BaseDAO.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * 〈封装了针对于数据表的通用的操作--基础的DAO〉 * DAO:date(base) access object * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public abstract class BaseDAO&lt;T&gt; {private Class&lt;T&gt; clazz = null;public BaseDAO() { //实际是在子类中执行的! //获取当前BaseDAO的子类继承的父类中的泛型. Type genericSuperclass = this.getClass().getGenericSuperclass(); ParameterizedType paramType = (ParameterizedType) genericSuperclass; Type[] typeArguments = paramType.getActualTypeArguments();//获取父类的泛型参数 clazz = (Class&lt;T&gt;) typeArguments[0];//泛型的第一个参数}//通用的增删改操作 (version 2.0 考虑上事务,在形参列表中添加了连接,这样可以控制连接的关闭!)public int update(Connection conn, String sql, Object... args) {//sql中的占位符的个数与可变形参的占位符个数一致 PreparedStatement ps = null; try { //1.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]);//小心参数声明错误 } //3.执行 int i = ps.executeUpdate(); return i;//返回值,可以判断操作是否生效 } catch (Exception e) { e.printStackTrace(); } finally { //修改其为自动提交数据 //主要针对于使用数据库连接池的使用 try { conn.setAutoCommit(true); } catch (SQLException throwables) { throwables.printStackTrace(); } //5.资源的关闭 JDBCUtils.closeResource(null, ps);//不关闭连接. } return 0;}//通用的查询操作,用于返回数据表中的一条记录(version 2.0 : 考虑上事务)public T getInstance(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { //利用反射来造对象 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null;}//通用的查询操作,用于返回数据表中的多条记录构成的集合(version 2.0 : 考虑上事务)public List&lt;T&gt; getForList(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) { T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null;}//用于查询特殊值的通用的方法public &lt;E&gt; E getValue(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } rs = ps.executeQuery(); if (rs.next()) { return (E) rs.getObject(1); } } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null;}} ###【CustomerDAO.java】 123456789101112131415161718192021222324252627282930/** * 〈此接口用与规范针对于Customers表的常用操作〉 * * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public interface CustomerDAO { //将cust对象添加到数据库中 void insert(Connection conn, Customers cust); //针对指定的id,删除表中的一条记录 void deleteById(Connection conn,int id); //针对于内存中的cust对象,去修改数据表中的指定的记录 void update(Connection conn,Customers cust); //针对指定的id查询得到对应的Customer对象 Customers getCustomerById(Connection conn,int id); //查询表中的所有记录构成的集合 List&lt;Customers&gt; getAll(Connection conn); //返回数据表中数据的条目数量 Long getCount(Connection conn); //返回员工中最大的生日 java.sql.Date getMaxBirth(Connection conn);} ###【CustomerDAOImpl.java】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 〈针对于Customers表的具体实现方法〉 * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public class CustomerDAOImpl extends BaseDAO&lt;Customers&gt; implements CustomerDAO { @Override public void insert(Connection conn, Customers cust) { String sql = \"insert into customers(name,email,birth) values(?,?,?)\"; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth()); } @Override public void deleteById(Connection conn, int id) { String sql = \"delete from customers where id = ?\"; update(conn,sql,id); } @Override public void update(Connection conn, Customers cust) { String sql = \"update customers set name = ?,email = ?,birth = ? where id =?\"; update(conn,sql,cust.getName(),cust.getEmail(),cust.getBirth(),cust.getId()); } @Override public Customers getCustomerById(Connection conn, int id) { String sql = \"select id,name,email,birth from customers where id = ?\"; Customers cust = getInstance(conn, sql, id); if (cust != null){ return cust; }else { return null; } } @Override public List&lt;Customers&gt; getAll(Connection conn) { String sql = \"select id,name,email,birth from customers\"; List&lt;Customers&gt; list = getForList(conn, sql); if (list != null){ return list; }else { return null; } } @Override public Long getCount(Connection conn) { String sql = \"select count(*) from customers\"; return getValue(conn, sql); } @Override public Date getMaxBirth(Connection conn) { String sql =\"select max(birth) from customers\"; return getValue(conn,sql); }} ###【Customers.java】 123456public class Customers { private int id; private String name; private String email; private Date birth;} 二.总结：考虑到事务以后的数据库操作(重点)1.获取数据库的连接 Connection conn = JDBCUtils.getConnection(); //方式1：手动获取连接 ​ // 方式2: 数据库连接池 conn.setAutoCommit(false); //体现事务 2.如下的多个DML操作，作为一个事务出现： 操作1：需要使用通用的增删改查操作 //通用的增删改查操作如何实现？ //方式1：手动使用PreparedStatement实现操作2：需要使用通用的增删改查操作 //方式2：使用dbutils.jar中QueryRunner类 操作3：需要使用通用的增删改查操作 conn.commit(); 3.如果出现异常，则：conn.rollback(); 4.关闭资源JDBCUtils.closeResource(..,…,…); //方式1：手动关闭","link":"/2020/08/20/DAO%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB/"},{"title":"DAO及相关实现类","text":"@Author: Xue ZhenLong @Address: Beijing province, China 一.数据库连接池1.1 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 1.2 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 1.3 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 二.数据库连接池举例####配置驱动: 2.1 C3P0数据库连接池2.1.1连接12345678910111213141516171819202122232425262728293031323334/** * 〈数据库连接池C3P0〉 * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public class C3P0Test { //方式一:(不安全不推荐) @Test public void testGetConnecion1() throws Exception { //获取c3p0数据库连接池 ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass( \"com.mysql.jdbc.Driver\" ); //loads the jdbc driver cpds.setJdbcUrl( \"jdbc:mysql://localhost:3306/test\"); cpds.setUser(\"root\"); cpds.setPassword(\"123456xzl\"); //通过设置相关的参数,对数据库连接池进行管理: //设置初始时数据库连接池中的连接数 cpds.setInitialPoolSize(10); Connection conn = cpds.getConnection(); System.out.println(conn); } //方式二:使用配置文件(推荐使用!!!!) @Test public void testGetConnecion2() throws Exception { ComboPooledDataSource cpds = new ComboPooledDataSource(\"helloc3p0\"); Connection conn = cpds.getConnection(); System.out.println(conn); }} 2.1.2配置文件设置123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;c3p0-config&gt; &lt;named-config name=\"helloc3p0\"&gt; &lt;!-- 提供获取连接的4个基本信息 --&gt; &lt;property name=\"driverClass\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;123456xzl&lt;/property&gt; &lt;!-- 进行数据库连接池管理的基本信息 --&gt; &lt;!-- 当数据库连接池中的连接数不够是,c3p0一次性向数据库服务器申请的连接数 --&gt; &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt; &lt;!-- c3p0数据库连接池中初始化时的连接数 --&gt; &lt;property name=\"initialPoolSize\"&gt;10&lt;/property&gt; &lt;!-- c3p0数据库连接池中维护的最少的连接数 --&gt; &lt;property name=\"minPoolSize\"&gt;10&lt;/property&gt; &lt;!-- c3p0数据库连接池中维护的最多的连接数 --&gt; &lt;property name=\"maxPoolSize\"&gt;100&lt;/property&gt; &lt;!-- c3p0数据库连接池中维护的最多的Statement的个数 --&gt; &lt;property name=\"maxStatements\"&gt;50&lt;/property&gt; &lt;!-- 每个连接中可以最多使用的Statement的个数 --&gt; &lt;property name=\"maxStatementsPerConnection\"&gt;5&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 2.2 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 ####2.2.1 连接 获取连接方式一： 123456789101112public static Connection getConnection3() throws Exception { BasicDataSource source = new BasicDataSource(); source.setDriverClassName(\"com.mysql.jdbc.Driver\"); source.setUrl(\"jdbc:mysql:///test\"); source.setUsername(\"root\"); source.setPassword(\"123456xzl\"); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn;} 获取连接方式二： 12345678910111213141516171819//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐private static DataSource source = null;static{ try { Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(\"dbcp.properties\"); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } }public static Connection getConnection4() throws Exception { Connection conn = source.getConnection(); return conn;} 2.2.2配置文件设置src下的配置文件为：【dbcp.properties】 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=falseusername=rootpassword=abc123initialSize=10#... 2.3 (重点掌握)Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 ####2.3.1 连接 123456789101112131415161718192021222324/** * 〈数据库连接池Druid〉 * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public class DruidTest { @Test public void getConnection() throws Exception { Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"druid.properties\"); pros.load(is); DataSource source = DruidDataSourceFactory.createDataSource(pros); Connection conn = source.getConnection(); System.out.println(conn); }} 2.2.2配置文件设置src下的配置文件为：【druid.properties】 123456url=jdbc:mysql:///testusername=rootpassword=123456xzldriverClassName=com.mysql.jdbc.DriverinitialSize=10maxActive=10","link":"/2020/08/20/JDBC-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"title":"JDBC-事务","text":"@Author: Xue ZhenLong @Address: Beijing province, China 数据库事务1.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 1.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 1.3JDBC事务处理案例测试####1.3.1未考虑数据库事务的错误操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 *〈事务的测试〉 * 1.事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 * ---一组逻辑操作单元:一个或多个DML操作. * 2.事务处理的原则: * ---保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。 * 当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来； * 要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。 * 3.数据一旦提交,就不可以回滚. * 4.哪些操作会导致数据的自动提交? * ---DDL操作一旦执行,都会自动提交. * &gt;set autocommit = false对DDL操作失效 * ---DML默认情况下,一旦执行,就会自动提交 * &gt;我们可以通过set autocommit = false的方式取消DML操作的自动提交 * ---默认在关闭连接时,会自动的提交数据 * */public class TransactionTest { /* 针对于数据表user_table来说: AA用户给BB用户转账100元 update user_table set balance = balance - 100 where user = 'AA'; update user_table set balance = balance + 100 where user = 'BB'; */ //******************************未考虑数据库事务的错误操作*********************************\\\\ @Test public void testUpdate(){ String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(sql1,\"AA\"); System.out.println(10/0);//模拟网络异常 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(sql2,\"BB\"); System.out.println(\"转账成功!\"); } //对于 修改.删除.添加 操作进行封装! version 1.0 public int update(String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //4.执行 int i = ps.executeUpdate(); return i; } catch (Exception e) { e.printStackTrace(); }finally { //5.资源的关闭 JDBCUtils.closeResource(conn,ps); } return 0; } ####1.3.2考虑数据库事务的正确操作 123456789101112131415161718192021222324252627282930313233343536//******************************考虑数据库事务的正确操作*********************************\\\\ @Test public void testUpdateWithTx(){ Connection conn = null; try { //手动的创建连接 conn = JDBCUtils.getConnection(); //1.(关键)取消数据的自动提交功能!!!!!!!!!!!! conn.setAutoCommit(false); String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn,sql1,\"AA\"); //System.out.println(10/0);//模拟网络异常 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn,sql2,\"BB\"); System.out.println(\"转账成功!\"); //2.(关键)手动提交数据!!!!!!!!!!!! conn.commit(); } catch (Exception e) { e.printStackTrace(); //3.(关键)回滚数据 try { conn.rollback(); } catch (SQLException throwables) { throwables.printStackTrace(); } } finally { //修改其为自动提交数据 //主要针对于使用数据库连接池的使用 try { conn.setAutoCommit(true); } catch (SQLException throwables) { throwables.printStackTrace(); } JDBCUtils.closeResource(conn,null);//关闭连接 } } 12345678910111213141516171819202122//对于修改.删除.添加操作进行封装! version 2.0(考虑上事务,在形参列表中添加了连接,这样可以控制连接的关闭!) public int update(Connection conn,String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 PreparedStatement ps = null; try { //1.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //3.执行 int i = ps.executeUpdate(); return i;//返回值,可以判断操作是否生效 } catch (Exception e) { e.printStackTrace(); }finally { //4.资源的关闭 JDBCUtils.closeResource(null,ps);//不关闭连接. } return 0; }} 12345678910111213141516171819202122232425262728293031323334353637383940//通用的查询操作,用于返回数据表中的一条记录(version 2.0 : 考虑上事务) public T getInstance(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { //利用反射来造对象 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } 1234567891011121314151617181920212223242526272829303132333435363738394041424344//通用的查询操作,用于返回数据表中的多条记录构成的集合(version 2.0 : 考虑上事务) public List&lt;T&gt; getForList(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) { T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } 1.4事务的属性####1.4.1 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 1.4.2 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 1.4.3 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 1.4.4 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by 'abc123'; 授予权限 12345#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@'%' identified by 'abc123'; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123';","link":"/2020/08/20/JDBC%E4%BA%8B%E5%8A%A1/"},{"title":"JDBC-PreparedStatement","text":"@Author: Xue ZhenLong @Address: Beijing province, China 一. 使用PreparedStatement实现CRUD操作1. 操作数据库的流程1.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 1.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 2. PreparedStatement的使用2.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 2.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 2.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 2.4 对数据库连接与关闭的操作进行封装账户密码在properties中存储 1234user=rootpassword=123456xzlurl=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 连接: 123456789101112131415161718192021public static Connection getConnection() throws Exception { /* 获取数据库的连接操作 */ //1.读取配置文件中的4个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); //4.返回当前连接 return conn; } 关闭: 12345678910111213141516171819public static void closeResource(Connection conn, Statement ps) { /* 关闭连接和Statement的操作 */ try { if (ps != null) { ps.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } try { if (conn != null) { conn.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } } 2.5使用PreparedStatement实现增.删.改.操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) { PreparedStatementTest1 pst = new PreparedStatementTest1(); String name; String email; String birth; String sql = \"insert into customers(name,email,birth)value(?,?,?)\"; Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要添加的员工姓名:\"); name = sc.next(); System.out.println(\"请输入您要添加的员工邮箱地址:\"); email = sc.next(); System.out.println(\"请输入您要添加的员工出生日期:\"); birth = sc.next(); int update = pst.update(sql, name, email, birth); if (update &gt; 0) { System.out.println(\"恭喜您添加数据成功!!\"); } else { System.out.println(\"不好意思,没有添加成功\"); } sc.close(); }//对于 修改.删除.添加 操作进行封装!public int update(String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //4.执行 //execute只是执行,executeUpdate执行完毕后会返回操作成功的影响行数,以此可判断操作是否成功. int i = ps.executeUpdate(); return i; } catch (Exception e) { e.printStackTrace(); }finally { //5.资源的关闭 JDBCUtils.closeResource(conn,ps); } return 0;} 2.6使用PreparedStatement实现查询操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Testpublic void testGetForList(){ String sql = \"select id,name,email from customers where id&lt; ?\"; List&lt;Customers&gt; list = getForList(Customers.class, sql, 12); Iterator&lt;Customers&gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); }}public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz,String sql,Object...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //创建连接 conn = JDBCUtils.getConnection(); //预编译sql语句 ps = conn.prepareStatement(sql); //填写占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()){ T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel()// String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i+1);//利用反射,将对象指定名的属性赋 值名columnName,为指定的值 columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t,columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps,rs); } return null;} 2.6使用PreparedStatement操作Blob类型的变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 〈使用PreparedStatement操作Blob类型的数据〉 * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 */public class BlobTest { //向数据表customers中插入Blob类型的字段 @Test public void testInsert(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth,photo) values(?,?,?,?)\"; ps = conn.prepareStatement(sql); ps.setObject(1,\"小小薛\"); ps.setObject(2,\"xue@gmail.com\"); ps.setObject(3,\"2000-6-7\"); FileInputStream is = new FileInputStream(new File(\"dog.jpg\")); ps.setBlob(4,is); ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } //查询数据表customers中Blob类型的字段 @Test public void testQuery(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth,photo from customers where id= ?\"; ps = conn.prepareStatement(sql); ps.setObject(1,894); rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); if (rs.next()){ Customers customer = new Customers(); for (int i = 0; i &lt;columnCount-1 ; i++) { String ColumnLabel = metaData.getColumnLabel(i+1); Object object = rs.getObject(i + 1); //反射的方式进行属性的赋值 Field field =customer.getClass().getDeclaredField(ColumnLabel); field.setAccessible(true); field.set(customer,object); } System.out.println(customer); //将Blob类型的字段下载下来,以文件的方式保存在本地 InputStream is = null; FileOutputStream fos = null; try { Blob photo = rs.getBlob(\"photo\"); is = photo.getBinaryStream(); fos = new FileOutputStream(\"xiaogougou.jpg\"); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"恭喜您图片下载成功到本地!!\"); } catch (SQLException throwables) { throwables.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { is.close(); } if(fos != null){ fos.close(); } } } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps,rs); } }} 2.7使用PreparedStatement实现高效的批量插入重点掌握方式四 方式一:Statement12345678910111213141516171819202122/** * 〈使用PreparedStatement实现批量数据的操作〉 * update delete 本身就具有批量操作的效果 * 此时的批量操作,主要指的是insert 批量插入. * 使用PreparedStatement如何实现更高效的批量插入 * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 * 题目:向goods表中插入20000条数据 * CREATE TABLE goods( * id INT PRIMARY KEY AUTO_INCREMENT, * NAME VARCHAR(25) * ); */ //方式一:使用Statement Connection conn = JDBCUtils.getConnection(); Statement st = conn.creatStatement(); for (int i = 0;i &lt;= 20000; i++){ String sql = \"insert into goods(name) value('nameJ_\"+i+\"')\"; st.execute(sql);} 方式二:PreparedStatement1234567891011121314151617181920212223//方式二:使用PreparedStatement @Test public void testInsert1(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); ps.execute(); } long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11114ms } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } 方式三:Batch12345678910111213141516171819202122232425262728293031323334353637//方式三:/* 1.addBatch() executeBatch() clearBatch() 2.mysql服务器默认是关闭批处理的,我们需要通过一个参数, 让mysql开启批处理的支持. ?rewriteBatchedStatements=true 写在配置文件的url后面 3.使用更新的mysql驱动: mysql-connector-java-5.1.37-bin.jar */@Testpublic void testInsert2(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); //1.\"攒\"sql ps.addBatch(); if (i % 20 == 0){ //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); } } long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11114ms--&gt;11043ms 不知道为啥 懵逼了 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); }} 方式四:setAutoCommit(false)1234567891011121314151617181920212223242526272829303132333435363738 //方式四:设置连接不允许自动提交,手动进行提交(重点掌握!!!)/** 在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/ @Test public void testInsert3(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); //设置不允许自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); //1.\"攒\"sql ps.addBatch(); if (i % 20 == 0){ //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); } } //手动进行提交 conn.commit(); long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11043ms --&gt;1108ms } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } 总结：PreparedStatement与Statement的异同？① 指出二者的关系？ 接口 与 子接口的关系② 开发中，PreparedStatement替换Statement③ An object that represents a precompiled SQL statement","link":"/2020/08/18/JDBC-PreparedStatement/"},{"title":"Apache-DBUtils实现CRUD操作","text":"@Author: Xue ZhenLong @Address: Beijing province, China ##一.Apache-DBUtils实现CRUD操作 1.1 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 1.2 主要API的使用1.2.1 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 1.2.2 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。 …… 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 …. 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 …… 1.3 测试代码举例1.3.1 测试插入 123456789101112131415161718192021222324252627282930/** * 〈commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装， * 学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。〉 * * @author XueZhenLonG * @create 2020/8/19 * @since 1.0.0 */public class QueryRunnerTest { //测试插入 (修改与删除同理!) @Test public void testInsert() throws SQLException { Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"insert into customers(name,email,birth) value(?,?,?)\"; int update = runner.update(conn, sql, \"Druid\", \"Druid@qq.com\", \"2000-1-2\"); if (update&gt;0){ System.out.println(\"恭喜成功啦!!!\"); }else{ System.out.println(\"抱歉啊,失败了!!!\"); } } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } } 1.3.2 测试查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 //测试查询 /* BeanHandler:是ResultSetHandler接口的实现类,用于封装表中的一条记录. */ @Test public void testQuery1(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; BeanHandler&lt;Customers&gt; handler = new BeanHandler&lt;Customers&gt;(Customers.class); Customers cust = runner.query(conn, sql, handler, 2); System.out.println(cust); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } } /* BeanListHandler:是ResultSetHandler接口的实现类,用于封装表中的多条记录. */ @Test public void testQuery2(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; BeanListHandler&lt;Customers&gt; handler = new BeanListHandler&lt;Customers&gt;(Customers.class); List&lt;Customers&gt; cust = runner.query(conn, sql, handler, 10); cust.forEach(System.out::println); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } } /* MapHandler:是ResultSetHandler接口的实现类,对应表中的一条记录. 将字段及其相应字段的值作为map中的key和value */ @Test public void testQuery3(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id = ?\"; MapHandler handler = new MapHandler(); Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, 1); System.out.println(map); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } } /* MapListHandler:是ResultSetHandler接口的实现类,对应表中的多条记录. 将字段及其相应字段的值作为map中的key和value */ @Test public void testQuery4(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select id,name,email,birth from customers where id &lt; ?\"; MapListHandler handler = new MapListHandler(); List&lt;Map&lt;String, Object&gt;&gt; mapList = runner.query(conn, sql, handler, 10); mapList.forEach(System.out::println); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } } //查询customers表中的数据数量 //ScalarHandler:用于查询特殊值. @Test public void testQuery5(){ Connection conn = null; try { QueryRunner runner = new QueryRunner(); conn = JDBCUtils.getConnection3(); String sql = \"select count(*) from customers\"; ScalarHandler&lt;Long&gt; handler = new ScalarHandler&lt;&gt;(); Long query = runner.query(conn, sql, handler); System.out.println(\"customers表中共有:\"+query+\"条记录!\"); } catch (SQLException throwables) { throwables.printStackTrace(); } finally { JDBCUtils.closeResource2(conn,null,null); } }} 1.3.3 关闭操作优化 123456789101112131415161718192021 //Druid自带的自动关闭操作的封装!!(推荐!) public static void closeResource2(Connection conn, Statement ps, ResultSet rs){// try {// DbUtils.close(rs);// } catch (SQLException throwables) {// throwables.printStackTrace();// }// try {// DbUtils.close(ps);// } catch (SQLException throwables) {// throwables.printStackTrace();// }// try {// DbUtils.close(conn);// } catch (SQLException throwables) {// throwables.printStackTrace();// } DbUtils.closeQuietly(rs); DbUtils.closeQuietly(conn); DbUtils.closeQuietly(ps); } 1.4 JDBC操作总结 123456789101112131415161718192021222324252627282930//总结 @Testpublic void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0)//version2.0的增删改public void update(Connection conn,String sql,Object ... args){}//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 }}","link":"/2020/08/20/JDBC-DBUtils/"},{"title":"JDBC-连接","text":"@Author: Xue ZhenLong @Address: Beijing province, China 数据库连接的三要素要素一: Driver接口实现类1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： **com.mysql.jdbc.Driver 1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 要素二：URL2.1 URL的组成 JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 2.2 常用的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 (重点)数据库连接方式举例重点掌握方式五 12345678910111213141516171819202122//方式一:数据库的连接 @Test public void testConnection1() throws SQLException { //1.获取Driver的实现类对象 Driver driver = new com.mysql.jdbc.Driver(); //jdbc:mysql: 协议 //localhost: ip地址 //3306: 默认mysql的端口号 //test: test数据库 //2.创建url 连接的数据库地址 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); //将用户名和密码封装在properties中 info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 123456789101112131415161718//方式二:对方式一的迭代:在如下的程序中不出现第三方的api,是的程序具有更好的可以移植性. @Test public void testConnection2() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供要连接的数据库 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 12345678910111213141516171819//方式三:使用DriverManager替换Driver @Test public void testConnection3() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //3. 注册驱动 DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 12345678910111213141516171819202122232425//方式四:对方式三的迭代:可以只是加载驱动,不用显示的注册驱动过了. @Test public void testConnection4() throws Exception { //1. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //2. 加载Driver Class.forName(\"com.mysql.jdbc.Driver\"); /*Driver内部静态代码块中帮助我们创建了driver实例对象 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\");} } */// Driver driver = (Driver) clazz.newInstance();// //3. 注册驱动// DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 123456789101112131415161718192021222324//方式五(最终版):将数据库连接需要的4个基本信息声明在配置文件中,通过读取配置文件的方式,获取连接 /* 此种方法的好处: 1.实现了数据与代码的分离.实现解耦 2.如果需要修改配置文件信息,可以避免程序重新打包 */ @Test public void getConnection5() throws IOException, ClassNotFoundException, SQLException { //1.读取配置文件中的4个基本信息 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); }","link":"/2020/08/16/JDBC%E8%BF%9E%E6%8E%A5/"},{"title":"JDBC-概述","text":"@Author: Xue ZhenLong @Address: Beijing province, China ##JDBC-概述 ###1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。","link":"/2020/08/16/JDBC%E6%A6%82%E8%BF%B0/"},{"title":"我的博客建成日记","text":"@Author: Xue ZhenLong @Address: Beijing province, China 第一天 2020-8-81.学会了hexo的基本搭建2.测试了发布功能3.选择合适的主题icarus4.阅读主题作者的说明文档5.连接github 参考-官方文档:https://ppoffice.github.io/hexo-theme-icarus 第二天 2020-8-91.对于文章附带的图片进行测试2.增加夜间浏览模式3.增加bolg背景4.增加鼠标点击效果5.参考其对自己的博客进行部署.6.两个仓库的同步测试!—f**k 浪费了两个小时 失败了 我还是放弃吧…就用github了 这是一个重新部署环境的测试 呜呜呜呜 参考-夜间模式:https://www.imaegoo.com/2020/icarus-night-mode-3/-背景:https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1186779&amp;highlight=icarus-鼠标效果:https://zhuanlan.zhihu.com/p/69211731 第三天 2020-8-101.添加valine评论系统2.添加分享按钮ps:博客的基础功能完善 3.目录功能测试第四天 2020-8-101.两个仓库同步部署测试! 博客同时部署了coding 与 github page 国内coding会快很多. coding: https://1als1k.coding-pages.com/ github: https://xuezhenlong.work/ ps:花了一块钱买的域名 hhhhhhhh 总结:博客的基础功能已经实现,目前就这个样子了. 参考-评论:https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/","link":"/2020/08/08/Xue's%20Blog/"},{"title":"学习路线","text":"@Author: Xue ZhenLong @Address: Beijing province, China 一. 编程基础1. java语言1.语言基础 基础语法 面向对象 接口 容器 异常 泛型 反射 注解 I/O 图形化(如swing) 2. JVM 类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优 3. 并发/多线程 并发编程基础 线程池 锁 并发容器 原子类 juc并发工具 2. 数据结构和算法1. 数据结构 字符串 数组 链表 二叉树 堆.栈.队列 哈希 2. 算法 查找 排序 贪心 分治 动态规划 回溯 3. 计算机网络 ARP协议 IP/ICMP协议 TCP/UDP协议 DNS/HTTP/HTTPS协议 Session/Cookie 4. 数据库/SQL SQL语句书写 SQL语句优化 事物以及隔离级别 索引 锁 5. 操作系统 进程/线程 并发/锁 内存管理和调度 I/O原理 6. 设计模式 单例模式 工厂模式 代理模式 策略 模板方法 观察者 适配器 责任链 建造者 二. 开发工具1. 集成开发环境 Eclipse IDEA VSCode 2. Linux系统 Linux常用命令 基本Shell脚本 3. 代码管理工具 Git SVN 4. 项目管理/构建工具 Maven Gradle 三. 应用框架1. 后端1. Spring家族 Spring SpringMVC SpringBoot 2. 服务器软件 Web服务器 Nginx 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. 中间件 缓存 Redis 5大数据类型 事务 消息通知 管道 持久化 集群 memcache 消息队列 RocketMQ RabbitMq Kafka RPC结构 Dubbo GRPC Thrift SpringCloud Netty 4. 数据库 ORM层框架 Mybatis Hibernate JPA 连接池1. Druid 2. HikariCP 3. C3P0 分库分表1. Mycat 2. Sharding-JDBC 3. Sharding-Sphere 5. 搜索引擎 Solr ElasticSearch 6. 分布式/微服务 服务发现/注册1. Rureka 2. Consul 3. Zookeeper 4. Nacos 网关1. Zuul 2. Gateway 服务调用(负载均衡) Ribbon Feign 熔断/降级 Hystrix 配置中心 Config Apollo Nacos 认证和鉴权 Shiro SpringSecurity OAuch2 SSO 分布式事务 JTA接口 2PC/3PC XA模式 TCC模式 SAGA模式 LCN模式 任务调度 Quartz Rlastic-Job 链路追踪与监控 Zipkin Sleuth Skywalking 日志分析与监控 ELK 虚拟化/容器化 容器技术 容器编排技术 2. 前端1. 基础套餐 三大件 HEML Javascript CSS 基础库 Jquery Ajax 2. 模板框架 JSP/JSTL(了解 过时了) Thymeleaf FreeMarker 3. 组件化框架 Node VUE React Angular 四. 运维知识1. Web服务器​ 1. Nginx 2. 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. CDN加速4. 持续集成/持续发布 Jenkins 5. 代码质量检查 Sonar 6. 日志收集/分析 ELK 五. 平稳降落1.调节心态2. 虚心学习3. 持之以恒","link":"/2020/08/15/java%E5%AD%A6%E4%B9%A0/"},{"title":"我的博客建成日记","text":"@Author: Xue ZhenLong @Address: Beijing province, China ##重新启动博客的第一天 这是上传一个测试!!!","link":"/2021/01/17/%E5%B0%8F%E5%B0%8F%E8%96%9B%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"title":"MyBatis缓存","text":"@Author: Xue ZhenLong @Address: Beijing province, China MyBatis缓存MyBatis共有两级缓存: sqlSession级别的缓存， 一级缓存是一直开启的。 ##一级缓存:(本地缓存) MyBatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。（与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取相同的数据,直接从缓存中拿,没有必要再去查询数据库） 1、一级缓存的生命周期有多长？ a、MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。 c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。 d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用 2、怎么判断某两次查询是完全相同的查询？ Mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。 2.1 传入的statementId 2.2 查询时要求的结果集中的结果范围 2.3. 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 2.4 传递给java.sql.Statement要设置的参数值 3、一级缓存的失效情况: ​ 1.sqlSession不同​ 2.sqlSession相同,但是查询条件不同 (当前一级缓存中没有信息)​ 3.sqlSession相同,但是两次查询期间实现了增删改操作(这次增删改可能对数据有影响)​ 4.sqlSession相同,手动清除了一级缓存(缓存清空) 二级缓存:(全局缓存)​ MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能 ​ 基于namespace级别的缓存:一个namespace对应一个二级缓存 简介SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开席需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了，如果我们配置了二级缓存就意味着： 映射语句文件中的所有select语句将会被缓存。 映射语句文件中的所欲insert、update和delete语句会刷新缓存。 缓存会使用默认的Least Recently Used（LRU，最近最少使用的）算法来收回。 根据时间表，比如No Flush Interval,（CNFI没有刷新间隔），缓存不会以任何时间顺序来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的1024个引用 缓存会被视为是read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。 ###工作机制: ​ 1.一个会话,查询一条数据,这个数据就会被放在当前会话的一级缓存中;​ 2.如果会话关闭:一级缓存中的数据会被保存到二级缓存中;新的会话查询信息,就可以参照二级缓存中.​ 3.sqlSession ==&gt;EmployeeMapper==&gt;Employee​ DepartmentMapper==&gt;Department​ 不同namespace查出的数据会放在自己对应的缓存中(map) ​ 效果:数据会从二级缓存中获取​ (注意: 查出的数据都会被默认先放在一级缓存中,只有会话提交或者关闭以后,一级缓存中的数据才会转移到二级缓存) 二级缓存的使用:####二级缓存使用步骤： ​ 1.mybatis-config.xml Setting 中的 cacheEnabled–true​ 2.去mapper.xml中配置使用二级缓存 ​ 3.我们POJO需要实现序列化接口 缓存标签的属性设置：1234567891011121314&lt;cache eviction=\"LRU\" flushInterval=\"60000\" readOnly=\"false\" size=\"1024\"&gt; cache 标签有多个属性，一起来看一些这些属性分别代表什么意义 eviction: 缓存回收策略，有这几种回收策略 LRU - 最近最少回收，移除最长时间不被使用的对象 FIFO - 先进先出，按照缓存进入的顺序来移除它们 SOFT - 软引用，移除基于垃圾回收器状态和软引用规则的对象 WEAK - 弱引用，更积极的移除基于垃圾收集器和弱引用规则的对象 默认是 LRU 最近最少回收策略 flushInterval 缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值 readOnly:是否只读： true 只读，MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户。不安全，速度快。读写(默认)：MyBatis 觉得数据可能会被修改 false 非只读:mybatis觉得回去的数据可能会被修改 MyBatis会利用序列化&amp;反序列的技术克隆一份新的数据给你,安全,速度慢 size : 缓存存放多少个元素 type: 指定自定义缓存的全类名(实现Cache 接口即可) blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。 ##和缓存有关的设置/属性: ​ 1. :关闭缓存操作只是关闭二级缓存,一级缓存一直可用​ 2.每个select标签都有useCache=”true”​ false:关闭的是二级缓存 ​ 重点:​ 3.每个增删改查标签的:flushCache=”true”增删改查执行完成后就会清除缓存:​ 测试:flushCache=”true”一级缓存和二级缓存都会被清除​ 4.sqlSession.clearCache(); 只是清除当前session的一级缓存与二级缓存无关​ 5.localCacheScope:本地缓存作用域:(一级缓存SESSION);当前会话的所有数据​ STATEMENT:可以禁用一级缓存; 第三方缓存整合: 例如：EhcacheCache ​ 1.导入第三方缓存包​ 2.导入与第三方缓存整合的适配包:官方有​ 3.mapper.xml中使用自定义缓存​ 实践mybatis-config.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"src/config/dbconfig.properties\"&gt;&lt;/properties&gt; &lt;settings&gt;&lt;!-- 开启驼峰命名法至关重要!!!--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;&lt;!-- 显式的指定每个我们需要修改的配置的值,及时他是默认的.防止版本更新带来的问题--&gt;&lt;!-- 延迟加载的设置,当我们需要的时候再执行--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;!-- 二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias type=\"src.mybatis.bean.Employee\" alias=\"emp\"&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"url\" value=\"${d.url}\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"${d.username}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${d.password}\"&gt;&lt;/property&gt; &lt;property name=\"driver\" value=\"${d.driver}\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"src/config/EmployeeMapper.xml\"/&gt; &lt;/mappers&gt; EmployeeMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!--namespace:名称空间;指定为几口的全类名;id:唯一标识resultType: 返回值类型#{id} : 从传递过来的参数中取id值--&gt;&lt;mapper namespace=\"src.mybatis.dao.EmployeeMapper\"&gt;&lt;!--&lt;cache eviction=\"LRU\" flushInterval=\"60000\" readOnly=\"false\" size=\"1024\"&gt; cache 标签有多个属性，一起来看一些这些属性分别代表什么意义 eviction: 缓存回收策略，有这几种回收策略 LRU - 最近最少回收，移除最长时间不被使用的对象 FIFO - 先进先出，按照缓存进入的顺序来移除它们 SOFT - 软引用，移除基于垃圾回收器状态和软引用规则的对象 WEAK - 弱引用，更积极的移除基于垃圾收集器和弱引用规则的对象 默认是 LRU 最近最少回收策略 flushInterval 缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值 readOnly: 是否只读； true 只读，MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户。 不安全，速度快。读写(默认)：MyBatis 觉得数据可能会被修改 false 非只读:mybatis觉得回去的数据可能会被修改 MyBatis会利用序列化&amp;反序列的技术克隆一份新的数据给你,安全,速度慢 size : 缓存存放多少个元素 type: 指定自定义缓存的全类名(实现Cache 接口即可) blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。--&gt; &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt;&lt;/cache&gt; &lt;select id=\"getEmpById\" resultType=\"emp\"&gt; select * from tbl_employee where id = #{id} &lt;/select&gt;&lt;/mapper&gt; Employee. Class 1234567891011121314/** * 〈员工类〉 * @author XueZhenLonG * @create 2021/1/15 * @since 1.0.0 */@Alias(\"emp\")public class Employee implements Serializable { private Integer id; private String lastName; private String email; private String gender; private Department dept;} EmployeeMapper接口 123public interface EmployeeMapper { public Employee getEmpById(Integer id);} MybatisCacheTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package src.mybatis.test;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import src.mybatis.bean.Employee;import src.mybatis.dao.EmployeeMapper;import java.io.IOException;import java.io.InputStream;/** * 〈mybatis缓存的学习测试〉 * @author XueZhenLonG * @create 2021/1/16 * @since 1.0.0 */public class MybatisCacheTest { /** * 测试一级缓存 * @throws IOException */ @Test public void testFirstLevelCache() throws IOException { //1.根据xml配置文件(全局配置文件)创建一个SqlSessionFactory对象 String resource = \"src/config/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.获取sqlSession实例,能够执行已经映射的sql语句 //sql的唯一标识:statement Unique identifier matching the statement //执行sql要用的参数 SqlSession openSession = sqlSessionFactory.openSession(); SqlSession openSession1 = sqlSessionFactory.openSession(); try { EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); EmployeeMapper mapper1 = openSession1.getMapper(EmployeeMapper.class); Employee emp1 = mapper.getEmpById(1); System.out.println(emp1);// 通过日志信息我们可以看到就发送了一个sql语句 表名存在一级缓存 Employee emp2 = mapper.getEmpById(1); System.out.println(emp2); System.out.print(\"sqlSession相同的情况下:\"); System.out.println(emp1 == emp2); //true// 一级缓存的失效情况:// 1.sqlSession不同 Employee emp3 = mapper1.getEmpById(1); System.out.print(\"sqlSession不同的情况下:\"); System.out.println(emp3 ==emp1);// 2.sqlSession相同,查询条件不同(当前一级缓存中没有信息)// 3.sqlSession相同,但是两次查询期间实现了增删改操作// 4.sqlSession相同,手动清除了一级缓存(缓存清空) openSession.clearCache(); Employee emp4 = mapper.getEmpById(1); System.out.print(\"sqlSession相同的情况下,但是清除过缓存:\"); System.out.println(emp1 ==emp4); openSession1.commit(); openSession.commit(); } finally { openSession.close(); openSession1.close(); } } //一级缓存的测试结果 Employee{id=1, lastName='tom', email='tom@qq.com', gender='W', dept=null} DEBUG 01-17 18:23:40,641 Cache Hit Ratio [src.mybatis.dao.EmployeeMapper]: 0.0 (LoggingCache.java:60) Employee{id=1, lastName='tom', email='tom@qq.com', gender='W', dept=null} sqlSession相同的情况下:true DEBUG 01-17 18:23:40,641 Cache Hit Ratio [src.mybatis.dao.EmployeeMapper]: 0.0 (LoggingCache.java:60) DEBUG 01-17 18:23:40,645 ==&gt; Preparing: select * from tbl_employee where id = ? (BaseJdbcLogger.java:137) DEBUG 01-17 18:23:40,645 ==&gt; Parameters: 1(Integer) (BaseJdbcLogger.java:137) DEBUG 01-17 18:23:40,646 &lt;== Total: 1 (BaseJdbcLogger.java:137) sqlSession不同的情况下:false DEBUG 01-17 18:23:40,647 Cache Hit Ratio [src.mybatis.dao.EmployeeMapper]: 0.0 (LoggingCache.java:60) DEBUG 01-17 18:23:40,647 ==&gt; Preparing: select * from tbl_employee where id = ? (BaseJdbcLogger.java:137) DEBUG 01-17 18:23:40,647 ==&gt; Parameters: 1(Integer) (BaseJdbcLogger.java:137) DEBUG 01-17 18:23:40,648 &lt;== Total: 1 (BaseJdbcLogger.java:137) sqlSession相同的情况下,但是清除过缓存:false DEBUG 01-17 18:23:40,648 put added 0 on heap (Segment.java:425) DEBUG 01-17 18:23:40,650 put added 0 on heap (Segment.java:425) DEBUG 01-17 18:23:40,650 put updated, deleted 0 on heap (Segment.java:453) /** * 测试二级缓存 * @throws IOException */ @Test public void testSecondLevelCache() throws IOException { //1.根据xml配置文件(全局配置文件)创建一个SqlSessionFactory对象 String resource = \"src/config/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.获取sqlSession实例,能够执行已经映射的sql语句 //sql的唯一标识:statement Unique identifier matching the statement //执行sql要用的参数 SqlSession openSession = sqlSessionFactory.openSession(); SqlSession openSession1 = sqlSessionFactory.openSession(); try { EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class); EmployeeMapper mapper1 = openSession1.getMapper(EmployeeMapper.class); Employee emp = mapper.getEmpById(1); System.out.println(emp); openSession.close(); //第二次查询是从二级缓存中拿到的数据,并没有发送新的sql Employee emp1 = mapper1.getEmpById(1); System.out.println(emp1); openSession1.close(); }finally { } } //二级缓存测试的结果 DEBUG 01-17 18:24:33,000 ==&gt; Preparing: select * from tbl_employee where id = ? (BaseJdbcLogger.java:137) DEBUG 01-17 18:24:33,017 ==&gt; Parameters: 1(Integer) (BaseJdbcLogger.java:137) DEBUG 01-17 18:24:33,026 &lt;== Total: 1 (BaseJdbcLogger.java:137) Employee{id=1, lastName='tom', email='tom@qq.com', gender='W', dept=null} DEBUG 01-17 18:24:33,027 put added 0 on heap (Segment.java:425) DEBUG 01-17 18:24:33,029 Cache Hit Ratio [src.mybatis.dao.EmployeeMapper]: 0.5 (LoggingCache.java:60) Employee{id=1, lastName='tom', email='tom@qq.com', gender='W', dept=null}}","link":"/2021/01/17/Mybatis%E7%BC%93%E5%AD%98/"},{"title":"SpringMVC_HelloWorld","text":"@Author: Xue ZhenLong @Address: Beijing province, China 第一章 SpringMVC 概述1. SpringMVC 概述① Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的 MVC 框架之一。 ② Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。 ③ Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。 ④ 支持 REST 风格的 URL 请求。 ⑤ 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。 2. 是什么① 一种轻量级的、基于MVC**的Web**层应用框架。偏前端而不是基于业务逻辑层。 ② 是Spring框架的一个后续产品。 3. 能干什么l 天生与Spring框架集成，如：(IOC,AOP) l 支持Restful风格 l 进行更简洁的Web层开发 l 支持灵活的URL到页面控制器的映射 l 非常容易与其他视图技术集成，如:Velocity、FreeMarker等等。 l 因为模型数据不存放在特定的API里，而是放在一个Model里(Map数据结构实现，因此很容易被其他框架使用) l 非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定，不必实现特定框架的API l 更加简单、强大的异常处理 l 对静态资源的支持 l 支持灵活的本地化、主题等解析 4. SpringMVC的MVC实现思想 ​ 5. 怎么玩l 将Web层进行了职责解耦，也就和struts2一样，基于请求-响应模型 l 常用主要组件 u DispatcherServlet：前端控制器 u Controller：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理 u HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个HandlerExecutiongChain对象（包含一个Handler处理器(页面控制器)对象、多个HandlerInterceptor拦截器对象） u ViewResolver : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体的View,进行这种策略模式，很容易更换其他视图技术； n 如InternalResourceViewResolver将逻辑视图名映射为JSP视图 u LocalResolver：本地化、国际化 u MultipartResolver：文件上传解析器 u HandlerExceptionResolver：异常处理器 6.第一个SpringMVC工程springMVC的搭建过程: 1.创建一个SpringMVC工程![](/springmvc/springmvc helloworld_01.png) ![](/springmvc/springmvc helloworld_02.png) ###2.接下来会自动的下载jar包等待即可 ![](/springmvc/springmvc helloworld_03.png) ###3.导入jstl.jar与standard.jar ![](/springmvc/springmvc helloworld_04.png) ###4.编写index.jsp/ web.xml/ springmvc-servlet.xml/TestController.java ![](/springmvc/springmvc helloworld_05.png) 4.1 wbl.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置DispatcherServlet的初始化參數：设置文件的路径和文件名称 --&gt;&lt;!-- &lt;context-param&gt;--&gt;&lt;!-- &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;&lt;!-- &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;--&gt;&lt;!-- &lt;/context-param&gt;--&gt;&lt;!-- &lt;listener&gt;--&gt;&lt;!-- &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;--&gt;&lt;!-- &lt;/listener&gt;--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4.2 springmvc-servlet.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 扫描组件,将加上@Controller注解的类作为springMVC的控制层--&gt; &lt;!-- 扫描器 --&gt;&lt;!-- &lt;mvc:default-servlet-handler/&gt;--&gt;&lt;!-- &lt;mvc:annotation-driven/&gt;--&gt; &lt;context:component-scan base-package=\"cn.xzl.mvc.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置映射解析器：如何将控制器返回的结果字符串，转换为一个物理的视图文件 作用:将prefix + 视图名称 + suffix 确定最终要跳转的页面 /WEB-INF/views/success.jsp --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3 index.jsp123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: XueZhenLonG Date: 2021/1/18 Time: 13:17 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" pageEncoding=\"utf-8\" %&gt;&lt;%@taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/hello\"&gt;say&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; ####4.4 TestController.java 1234567891011121314151617181920212223package cn.xzl.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * 〈测试 SpringMVC helloWorld〉 * @author XueZhenLonG * @create 2021/1/18 * @since 1.0.0 */@Controllerpublic class TestController { public static void main(String[] args) { System.out.println(\"我进入controller了!\");; } /** * 假设:localhost:8080/springmvc/hello */ @RequestMapping(value = \"/hello\") public String hello(){ System.out.println(\"收到请求,处理中...\"); return \"success\"; }} ###5.配置tomcat ![](/springmvc/springmvc helloworld_06.png) ###6.在tomcat中添加项目 ![](/springmvc/springmvc helloworld_07.png) ###7.在Project Structure中修复问题 ![](/springmvc/springmvc helloworld_08.png) ###8.运行项目 ![](/springmvc/springmvc helloworld_09.png) ![](/springmvc/springmvc helloworld_10.png)","link":"/2021/01/18/SpringMVC_HelloWorld/"}],"tags":[{"name":"java web","slug":"java-web","link":"/tags/java-web/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"学习路线","slug":"学习路线","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"}],"categories":[]}