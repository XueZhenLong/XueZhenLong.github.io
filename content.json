{"pages":[],"posts":[{"title":"JDBC-PreparedStatement","text":"一. 使用PreparedStatement实现CRUD操作1. 操作数据库的流程1.1 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 1.2 使用Statement操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 12int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETEResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 2. PreparedStatement的使用2.1 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 2.2 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 2.3 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 2.4 对数据库连接与关闭的操作进行封装账户密码在properties中存储 1234user=rootpassword=123456xzlurl=jdbc:mysql://localhost:3306/testdriverClass=com.mysql.jdbc.Driver 连接: 123456789101112131415161718192021public static Connection getConnection() throws Exception { /* 获取数据库的连接操作 */ //1.读取配置文件中的4个基本信息 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); //4.返回当前连接 return conn; } 关闭: 12345678910111213141516171819public static void closeResource(Connection conn, Statement ps) { /* 关闭连接和Statement的操作 */ try { if (ps != null) { ps.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } try { if (conn != null) { conn.close(); } } catch (SQLException throwables) { throwables.printStackTrace(); } } 2.5使用PreparedStatement实现增.删.改.操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) { PreparedStatementTest1 pst = new PreparedStatementTest1(); String name; String email; String birth; String sql = \"insert into customers(name,email,birth)value(?,?,?)\"; Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要添加的员工姓名:\"); name = sc.next(); System.out.println(\"请输入您要添加的员工邮箱地址:\"); email = sc.next(); System.out.println(\"请输入您要添加的员工出生日期:\"); birth = sc.next(); int update = pst.update(sql, name, email, birth); if (update &gt; 0) { System.out.println(\"恭喜您添加数据成功!!\"); } else { System.out.println(\"不好意思,没有添加成功\"); } sc.close(); }//对于 修改.删除.添加 操作进行封装!public int update(String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //4.执行 //execute只是执行,executeUpdate执行完毕后会返回操作成功的影响行数,以此可判断操作是否成功. int i = ps.executeUpdate(); return i; } catch (Exception e) { e.printStackTrace(); }finally { //5.资源的关闭 JDBCUtils.closeResource(conn,ps); } return 0;} 2.6使用PreparedStatement实现查询操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Testpublic void testGetForList(){ String sql = \"select id,name,email from customers where id&lt; ?\"; List&lt;Customers&gt; list = getForList(Customers.class, sql, 12); Iterator&lt;Customers&gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.println(iterator.next()); }}public &lt;T&gt; List&lt;T&gt; getForList(Class&lt;T&gt; clazz,String sql,Object...args){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //创建连接 conn = JDBCUtils.getConnection(); //预编译sql语句 ps = conn.prepareStatement(sql); //填写占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()){ T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel()// String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i+1);//利用反射,将对象指定名的属性赋 值名columnName,为指定的值 columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t,columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps,rs); } return null;} 2.6使用PreparedStatement操作Blob类型的变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 〈使用PreparedStatement操作Blob类型的数据〉 * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 */public class BlobTest { //向数据表customers中插入Blob类型的字段 @Test public void testInsert(){ Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = \"insert into customers(name,email,birth,photo) values(?,?,?,?)\"; ps = conn.prepareStatement(sql); ps.setObject(1,\"小小薛\"); ps.setObject(2,\"xue@gmail.com\"); ps.setObject(3,\"2000-6-7\"); FileInputStream is = new FileInputStream(new File(\"dog.jpg\")); ps.setBlob(4,is); ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } //查询数据表customers中Blob类型的字段 @Test public void testQuery(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtils.getConnection(); String sql = \"select id,name,email,birth,photo from customers where id= ?\"; ps = conn.prepareStatement(sql); ps.setObject(1,894); rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); if (rs.next()){ Customers customer = new Customers(); for (int i = 0; i &lt;columnCount-1 ; i++) { String ColumnLabel = metaData.getColumnLabel(i+1); Object object = rs.getObject(i + 1); //反射的方式进行属性的赋值 Field field =customer.getClass().getDeclaredField(ColumnLabel); field.setAccessible(true); field.set(customer,object); } System.out.println(customer); //将Blob类型的字段下载下来,以文件的方式保存在本地 InputStream is = null; FileOutputStream fos = null; try { Blob photo = rs.getBlob(\"photo\"); is = photo.getBinaryStream(); fos = new FileOutputStream(\"xiaogougou.jpg\"); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer)) != -1){ fos.write(buffer,0,len); } System.out.println(\"恭喜您图片下载成功到本地!!\"); } catch (SQLException throwables) { throwables.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { is.close(); } if(fos != null){ fos.close(); } } } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps,rs); } }} 2.7使用PreparedStatement实现高效的批量插入重点掌握方式四 方式一:Statement12345678910111213141516171819202122/** * 〈使用PreparedStatement实现批量数据的操作〉 * update delete 本身就具有批量操作的效果 * 此时的批量操作,主要指的是insert 批量插入. * 使用PreparedStatement如何实现更高效的批量插入 * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 * 题目:向goods表中插入20000条数据 * CREATE TABLE goods( * id INT PRIMARY KEY AUTO_INCREMENT, * NAME VARCHAR(25) * ); */ //方式一:使用Statement Connection conn = JDBCUtils.getConnection(); Statement st = conn.creatStatement(); for (int i = 0;i &lt;= 20000; i++){ String sql = \"insert into goods(name) value('nameJ_\"+i+\"')\"; st.execute(sql);} 方式二:PreparedStatement1234567891011121314151617181920212223//方式二:使用PreparedStatement @Test public void testInsert1(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); ps.execute(); } long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11114ms } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } 方式三:Batch12345678910111213141516171819202122232425262728293031323334353637//方式三:/* 1.addBatch() executeBatch() clearBatch() 2.mysql服务器默认是关闭批处理的,我们需要通过一个参数, 让mysql开启批处理的支持. ?rewriteBatchedStatements=true 写在配置文件的url后面 3.使用更新的mysql驱动: mysql-connector-java-5.1.37-bin.jar */@Testpublic void testInsert2(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); //1.\"攒\"sql ps.addBatch(); if (i % 20 == 0){ //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); } } long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11114ms--&gt;11043ms 不知道为啥 懵逼了 } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); }} 方式四:setAutoCommit(false)1234567891011121314151617181920212223242526272829303132333435363738 //方式四:设置连接不允许自动提交,手动进行提交(重点掌握!!!)/** 在层次三的基础上操作* 使用Connection 的 setAutoCommit(false) / commit()*/ @Test public void testInsert3(){ Connection conn = null; PreparedStatement ps = null; try { long l = System.currentTimeMillis(); conn = JDBCUtils.getConnection(); //设置不允许自动提交数据 conn.setAutoCommit(false); String sql = \"insert into goods(name) value(?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt;=20000; i++) { ps.setObject(1,\"name_\"+i); //1.\"攒\"sql ps.addBatch(); if (i % 20 == 0){ //2.执行batch ps.executeBatch(); //3.清空batch ps.clearBatch(); } } //手动进行提交 conn.commit(); long l1 = System.currentTimeMillis(); long time = l1-l; System.out.println(\"花费的时间为:\"+time);//11043ms --&gt;1108ms } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn,ps); } } 总结：PreparedStatement与Statement的异同？① 指出二者的关系？ 接口 与 子接口的关系② 开发中，PreparedStatement替换Statement③ An object that represents a precompiled SQL statement","link":"/2020/08/18/JDBC-PreparedStatement/"},{"title":"JDBC-事务","text":"数据库事务1.1 数据库事务介绍 事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)**，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)**到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 1.2 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个 SQL 语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 1.3JDBC事务处理案例测试####1.3.1未考虑数据库事务的错误操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * @author XueZhenLonG * @create 2020/8/18 * @since 1.0.0 *〈事务的测试〉 * 1.事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。 * ---一组逻辑操作单元:一个或多个DML操作. * 2.事务处理的原则: * ---保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。 * 当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来； * 要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。 * 3.数据一旦提交,就不可以回滚. * 4.哪些操作会导致数据的自动提交? * ---DDL操作一旦执行,都会自动提交. * &gt;set autocommit = false对DDL操作失效 * ---DML默认情况下,一旦执行,就会自动提交 * &gt;我们可以通过set autocommit = false的方式取消DML操作的自动提交 * ---默认在关闭连接时,会自动的提交数据 * */public class TransactionTest { /* 针对于数据表user_table来说: AA用户给BB用户转账100元 update user_table set balance = balance - 100 where user = 'AA'; update user_table set balance = balance + 100 where user = 'BB'; */ //******************************未考虑数据库事务的错误操作*********************************\\\\ @Test public void testUpdate(){ String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(sql1,\"AA\"); System.out.println(10/0);//模拟网络异常 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(sql2,\"BB\"); System.out.println(\"转账成功!\"); } //对于 修改.删除.添加 操作进行封装! version 1.0 public int update(String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //4.执行 int i = ps.executeUpdate(); return i; } catch (Exception e) { e.printStackTrace(); }finally { //5.资源的关闭 JDBCUtils.closeResource(conn,ps); } return 0; } ####1.3.2考虑数据库事务的正确操作 123456789101112131415161718192021222324252627282930313233343536//******************************考虑数据库事务的正确操作*********************************\\\\ @Test public void testUpdateWithTx(){ Connection conn = null; try { //手动的创建连接 conn = JDBCUtils.getConnection(); //1.(关键)取消数据的自动提交功能!!!!!!!!!!!! conn.setAutoCommit(false); String sql1 = \"update user_table set balance = balance - 100 where user = ?\"; update(conn,sql1,\"AA\"); //System.out.println(10/0);//模拟网络异常 String sql2 = \"update user_table set balance = balance + 100 where user = ?\"; update(conn,sql2,\"BB\"); System.out.println(\"转账成功!\"); //2.(关键)手动提交数据!!!!!!!!!!!! conn.commit(); } catch (Exception e) { e.printStackTrace(); //3.(关键)回滚数据 try { conn.rollback(); } catch (SQLException throwables) { throwables.printStackTrace(); } } finally { //修改其为自动提交数据 //主要针对于使用数据库连接池的使用 try { conn.setAutoCommit(true); } catch (SQLException throwables) { throwables.printStackTrace(); } JDBCUtils.closeResource(conn,null);//关闭连接 } } 12345678910111213141516171819202122//对于修改.删除.添加操作进行封装! version 2.0(考虑上事务,在形参列表中添加了连接,这样可以控制连接的关闭!) public int update(Connection conn,String sql,Object...args){//sql中的占位符的个数与可变形参的占位符个数一致 PreparedStatement ps = null; try { //1.预编译sql语句,返回PreparedStatement的实例 ps = conn.prepareStatement(sql); //2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i+1,args[i]);//小心参数声明错误 } //3.执行 int i = ps.executeUpdate(); return i;//返回值,可以判断操作是否生效 } catch (Exception e) { e.printStackTrace(); }finally { //4.资源的关闭 JDBCUtils.closeResource(null,ps);//不关闭连接. } return 0; }} 12345678910111213141516171819202122232425262728293031323334353637383940//通用的查询操作,用于返回数据表中的一条记录(version 2.0 : 考虑上事务) public T getInstance(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { //利用反射来造对象 T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } 1234567891011121314151617181920212223242526272829303132333435363738394041424344//通用的查询操作,用于返回数据表中的多条记录构成的集合(version 2.0 : 考虑上事务) public List&lt;T&gt; getForList(Connection conn, String sql, Object... args) { PreparedStatement ps = null; ResultSet rs = null; try { ps = conn.prepareStatement(sql); for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } //执行获取结果集 rs = ps.executeQuery(); //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 int columnCount = rsmd.getColumnCount(); //创建集合对象 ArrayList&lt;T&gt; list = new ArrayList&lt;T&gt;(); while (rs.next()) { T t = clazz.newInstance(); //处理结果集一行数据中的每一个列:给t对象指定的属性赋值 for (int i = 0; i &lt; columnCount; i++) { //获取每个列的列名 : 通过元数据 ResultSetMetaData //获取列的列名:getColumnName() //获取列的别名:getColumnLabel() // String columnName = rsmd.getColumnName(i + 1); --&gt;不推荐使用!! String columnLable = rsmd.getColumnLabel(i + 1); //获取每个列的列值 : 通过结果集 ResultSet Object columnValue = rs.getObject(i + 1); //利用反射,将对象指定名的属性赋 值名columnName,为指定的值columnValue Field field = t.getClass().getDeclaredField(columnLable); field.setAccessible(true); field.set(t, columnValue); } list.add(t); } return list; } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(null, ps, rs); } return null; } 1.4事务的属性####1.4.1 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 1.4.2 数据库的并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 1.4.3 四种隔离级别 数据库提供的4种事务隔离级别： Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。 Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 1.4.4 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: 1SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: 1set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: 1set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： 1create user tom identified by 'abc123'; 授予权限 12345#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.grant all privileges on *.* to tom@'%' identified by 'abc123'; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123';","link":"/2020/08/20/JDBC%E4%BA%8B%E5%8A%A1/"},{"title":"JDBC-概述","text":"##JDBC-概述 ###1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 1.2 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (Java Data Object )技术 第三方O/R工具，如Hibernate, Mybatis 等 JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。 1.3 JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC，那么Java程序访问数据库时是这样的： 有了JDBC，Java程序访问数据库时是这样的： 总结如下： 1.4 JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 1.5 JDBC程序编写步骤 补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。","link":"/2020/08/16/JDBC%E6%A6%82%E8%BF%B0/"},{"title":"JDBC-连接","text":"数据库连接的三要素要素一: Driver接口实现类1.1 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver mySql的驱动： **com.mysql.jdbc.Driver 1.2 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 要素二：URL2.1 URL的组成 JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 举例： 2.2 常用的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/atguigu jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456 Oracle 9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:atguigu SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=atguigu 要素三：用户名和密码 user,password可以用“属性名=属性值”方式告诉数据库 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接 (重点)数据库连接方式举例重点掌握方式五 12345678910111213141516171819202122//方式一:数据库的连接 @Test public void testConnection1() throws SQLException { //1.获取Driver的实现类对象 Driver driver = new com.mysql.jdbc.Driver(); //jdbc:mysql: 协议 //localhost: ip地址 //3306: 默认mysql的端口号 //test: test数据库 //2.创建url 连接的数据库地址 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); //将用户名和密码封装在properties中 info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 123456789101112131415161718//方式二:对方式一的迭代:在如下的程序中不出现第三方的api,是的程序具有更好的可以移植性. @Test public void testConnection2() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供要连接的数据库 String url = \"jdbc:mysql://localhost:3306/test\"; //3. 提供连接需要的用户名和密码 Properties info = new Properties(); info.setProperty(\"user\",\"root\"); info.setProperty(\"password\",\"123456xzl\"); //4. 获取连接 Connection connect = driver.connect(url, info); System.out.println(connect); } 12345678910111213141516171819//方式三:使用DriverManager替换Driver @Test public void testConnection3() throws Exception { //1. 获取Driver实现对象,利用反射来实现 Class&lt;?&gt; clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Driver driver = (Driver) clazz.newInstance(); //2. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //3. 注册驱动 DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 12345678910111213141516171819202122232425//方式四:对方式三的迭代:可以只是加载驱动,不用显示的注册驱动过了. @Test public void testConnection4() throws Exception { //1. 提供连接需要的用户名和密码 String url = \"jdbc:mysql://localhost:3306/test\"; String user = \"root\"; String password = \"123456xzl\"; //2. 加载Driver Class.forName(\"com.mysql.jdbc.Driver\"); /*Driver内部静态代码块中帮助我们创建了driver实例对象 static { try { DriverManager.registerDriver(new Driver()); } catch (SQLException var1) { throw new RuntimeException(\"Can't register driver!\");} } */// Driver driver = (Driver) clazz.newInstance();// //3. 注册驱动// DriverManager.registerDriver(driver); //4. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); } 123456789101112131415161718192021222324//方式五(最终版):将数据库连接需要的4个基本信息声明在配置文件中,通过读取配置文件的方式,获取连接 /* 此种方法的好处: 1.实现了数据与代码的分离.实现解耦 2.如果需要修改配置文件信息,可以避免程序重新打包 */ @Test public void getConnection5() throws IOException, ClassNotFoundException, SQLException { //1.读取配置文件中的4个基本信息 InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(\"xzl/cn/connection/jdbc.properties\"); Properties pros = new Properties(); pros.load(is); String user = pros.getProperty(\"user\"); String password = pros.getProperty(\"password\"); String url = pros.getProperty(\"url\"); String driverClass = pros.getProperty(\"driverClass\"); //2. 加载驱动 Class.forName(driverClass); //3. 获取连接 Connection conn = DriverManager.getConnection(url, user, password); System.out.println(conn); }","link":"/2020/08/16/JDBC%E8%BF%9E%E6%8E%A5/"},{"title":"我的博客建成日记","text":"第一天 2020-8-81.学会了hexo的基本搭建2.测试了发布功能3.选择合适的主题icarus4.阅读主题作者的说明文档5.连接github 参考-官方文档:https://ppoffice.github.io/hexo-theme-icarus 第二天 2020-8-91.对于文章附带的图片进行测试2.增加夜间浏览模式3.增加bolg背景4.增加鼠标点击效果5.参考其对自己的博客进行部署.6.两个仓库的同步测试!—f**k 浪费了两个小时 失败了 我还是放弃吧…就用github了 这是一个重新部署环境的测试 呜呜呜呜 参考-夜间模式:https://www.imaegoo.com/2020/icarus-night-mode-3/-背景:https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1186779&amp;highlight=icarus-鼠标效果:https://zhuanlan.zhihu.com/p/69211731 第三天 2020-8-101.添加valine评论系统2.添加分享按钮ps:博客的基础功能完善 3.目录功能测试第四天 2020-8-101.两个仓库同步部署测试! 博客同时部署了coding 与 github page 国内coding会快很多. coding: https://1als1k.coding-pages.com/ github: https://xuezhenlong.work/ ps:花了一块钱买的域名 hhhhhhhh 总结:博客的基础功能已经实现,目前就这个样子了. 参考-评论:https://blog.zhangruipeng.me/hexo-theme-icarus/categories/Plugins/Comment/","link":"/2020/08/08/Xue's%20Blog/"},{"title":"学习路线","text":"一. 编程基础1. java语言1.语言基础 基础语法 面向对象 接口 容器 异常 泛型 反射 注解 I/O 图形化(如swing) 2. JVM 类加载机制 字节码执行机制 JVM内存模型 GC垃圾回收 JVM性能监控与故障定位 JVM调优 3. 并发/多线程 并发编程基础 线程池 锁 并发容器 原子类 juc并发工具 2. 数据结构和算法1. 数据结构 字符串 数组 链表 二叉树 堆.栈.队列 哈希 2. 算法 查找 排序 贪心 分治 动态规划 回溯 3. 计算机网络 ARP协议 IP/ICMP协议 TCP/UDP协议 DNS/HTTP/HTTPS协议 Session/Cookie 4. 数据库/SQL SQL语句书写 SQL语句优化 事物以及隔离级别 索引 锁 5. 操作系统 进程/线程 并发/锁 内存管理和调度 I/O原理 6. 设计模式 单例模式 工厂模式 代理模式 策略 模板方法 观察者 适配器 责任链 建造者 二. 开发工具1. 集成开发环境 Eclipse IDEA VSCode 2. Linux系统 Linux常用命令 基本Shell脚本 3. 代码管理工具 Git SVN 4. 项目管理/构建工具 Maven Gradle 三. 应用框架1. 后端1. Spring家族 Spring SpringMVC SpringBoot 2. 服务器软件 Web服务器 Nginx 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. 中间件 缓存 Redis 5大数据类型 事务 消息通知 管道 持久化 集群 memcache 消息队列 RocketMQ RabbitMq Kafka RPC结构 Dubbo GRPC Thrift SpringCloud Netty 4. 数据库 ORM层框架 Mybatis Hibernate JPA 连接池1. Druid 2. HikariCP 3. C3P0 分库分表1. Mycat 2. Sharding-JDBC 3. Sharding-Sphere 5. 搜索引擎 Solr ElasticSearch 6. 分布式/微服务 服务发现/注册1. Rureka 2. Consul 3. Zookeeper 4. Nacos 网关1. Zuul 2. Gateway 服务调用(负载均衡) Ribbon Feign 熔断/降级 Hystrix 配置中心 Config Apollo Nacos 认证和鉴权 Shiro SpringSecurity OAuch2 SSO 分布式事务 JTA接口 2PC/3PC XA模式 TCC模式 SAGA模式 LCN模式 任务调度 Quartz Rlastic-Job 链路追踪与监控 Zipkin Sleuth Skywalking 日志分析与监控 ELK 虚拟化/容器化 容器技术 容器编排技术 2. 前端1. 基础套餐 三大件 HEML Javascript CSS 基础库 Jquery Ajax 2. 模板框架 JSP/JSTL(了解 过时了) Thymeleaf FreeMarker 3. 组件化框架 Node VUE React Angular 四. 运维知识1. Web服务器​ 1. Nginx 2. 应用服务器1. Tomcat 2. Jetty 3. Undertow 3. CDN加速4. 持续集成/持续发布 Jenkins 5. 代码质量检查 Sonar 6. 日志收集/分析 ELK 五. 平稳降落1.调节心态2. 虚心学习3. 持之以恒","link":"/2020/08/15/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"学习路线","slug":"学习路线","link":"/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"categories":[]}